const CovLine = require('./line')
const { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND } = require('source-map').SourceMapConsumer

module.exports = class CovSource {
  constructor (sourceRaw, wrapperLength) {
    sourceRaw = sourceRaw.trimEnd()
    this.lines = []
    this.eof = sourceRaw.length
    this.shebangLength = getShebangLength(sourceRaw)
    this.wrapperLength = wrapperLength - this.shebangLength
    this._buildLines(sourceRaw)
  }

  _buildLines (source) {
    let position = 0
    let ignoreCount = 0
    let ignoreAll = false
    for (const [i, lineStr] of source.split(/(?<=\r?\n)/u).entries()) {
      const line = new CovLine(i + 1, position, lineStr)
      if (ignoreCount > 0) {
        line.ignore = true
        ignoreCount--
      } else if (ignoreAll) {
        line.ignore = true
      }
      this.lines.push(line)
      position += lineStr.length

      const ignoreToken = this._parseIgnore(lineStr)
      if (!ignoreToken) continue

      line.ignore = true
      if (ignoreToken.count !== undefined) {
        ignoreCount = ignoreToken.count
      }
      if (ignoreToken.start || ignoreToken.stop) {
        ignoreAll = ignoreToken.start
        ignoreCount = 0
      }
    }
  }

  /**
   * Parses for comments:
   *    c8 ignore next
   *    c8 ignore next 3
   *    c8 ignore start
   *    c8 ignore stop
   * @param {string} lineStr
   * @return {{count?: number, start?: boolean, stop?: boolean}|undefined}
   */
  _parseIgnore (lineStr) {
    const testIgnoreNextLines = lineStr.match(/^\W*\/\* c8 ignore next (?<count>[0-9]+) *\*\/\W*$/)
    if (testIgnoreNextLines) {
      return { count: Number(testIgnoreNextLines.groups.count) }
    }

    // Check if comment is on its own line.
    if (lineStr.match(/^\W*\/\* c8 ignore next *\*\/\W*$/)) {
      return { count: 1 }
    }

    if (lineStr.match(/\/\* c8 ignore next \*\//)) {
      // Won't ignore successive lines, but the current line will be ignored.
      return { count: 0 }
    }

    const testIgnoreStartStop = lineStr.match(/\/\* c8 ignore (?<mode>start|stop) *\*\//)
    if (testIgnoreStartStop) {
      if (testIgnoreStartStop.groups.mode === 'start') return { start: true }
      if (testIgnoreStartStop.groups.mode === 'stop') return { stop: true }
    }
  }

  // given a start column and end column in absolute offsets within
  // a source file (0 - EOF), returns the relative line column positions.
  offsetToOriginalRelative (sourceMap, startCol, endCol) {
    const lines = this.lines.filter((line, i) => {
      return startCol <= line.endCol && endCol >= line.startCol
    })
    if (!lines.length) return {}

    const start = originalPositionTryBoth(
      sourceMap,
      lines[0].line,
      Math.max(0, startCol - lines[0].startCol)
    )
    let end = originalEndPositionFor(
      sourceMap,
      lines[lines.length - 1].line,
      endCol - lines[lines.length - 1].startCol
    )

    if (!(start && end)) {
      return {}
    }

    if (!(start.source && end.source)) {
      return {}
    }

    if (start.source !== end.source) {
      return {}
    }

    if (start.line === end.line && start.column === end.column) {
      end = sourceMap.originalPositionFor({
        line: lines[lines.length - 1].line,
        column: endCol - lines[lines.length - 1].startCol,
        bias: LEAST_UPPER_BOUND
      })
      end.column -= 1
    }

    return {
      source: start.source,
      startLine: start.line,
      relStartCol: start.column,
      endLine: end.line,
      relEndCol: end.column
    }
  }

  relativeToOffset (line, relCol) {
    line = Math.max(line, 1)
    if (this.lines[line - 1] === undefined) return this.eof
    return Math.min(this.lines[line - 1].startCol + relCol, this.lines[line - 1].endCol)
  }
}

// this implementation is pulled over from istanbul-lib-sourcemap:
// https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-source-maps/lib/get-mapping.js
//
/**
 * AST ranges are inclusive for start positions and exclusive for end positions.
 * Source maps are also logically ranges over text, thoug