this.workbox = this.workbox || {};
this.workbox.backgroundSync = (function (exports, WorkboxError_js, logger_js, assert_js, getFriendlyURL_js, DBWrapper_js) {
    'use strict';

    try {
      self['workbox:background-sync:5.1.4'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const DB_VERSION = 3;
    const DB_NAME = 'workbox-background-sync';
    const OBJECT_STORE_NAME = 'requests';
    const INDEXED_PROP = 'queueName';
    /**
     * A class to manage storing requests from a Queue in IndexedDB,
     * indexed by their queue name for easier access.
     *
     * @private
     */

    class QueueStore {
      /**
       * Associates this instance with a Queue instance, so entries added can be
       * identified by their queue name.
       *
       * @param {string} queueName
       * @private
       */
      constructor(queueName) {
        this._queueName = queueName;
        this._db = new DBWrapper_js.DBWrapper(DB_NAME, DB_VERSION, {
          onupgradeneeded: this._upgradeDb
        });
      }
      /**
       * Append an entry last in the queue.
       *
       * @param {Object} entry
       * @param {Object} entry.requestData
       * @param {number} [entry.timestamp]
       * @param {Object} [entry.metadata]
       * @private
       */


      async pushEntry(entry) {
        {
          assert_js.assert.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'pushEntry',
            paramName: 'entry'
          });
          assert_js.assert.isType(entry.requestData, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'pushEntry',
            paramName: 'entry.requestData'
          });
        } // Don't specify an ID since one is automatically generated.


        delete entry.id;
        entry.queueName = this._queueName;
        await this._db.add(OBJECT_STORE_NAME, entry);
      }
      /**
       * Prepend an entry first in the queue.
       *
       * @param {Object} entry
       * @param {Object} entry.requestData
       * @param {number} [entry.timestamp]
       * @param {Object} [entry.metadata]
       * @private
       */


      async unshiftEntry(entry) {
        {
          assert_js.assert.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'unshiftEntry',
            paramName: 'entry'
          });
          assert_js.assert.isType(entry.requestData, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'unshiftEntry',
            paramName: 'entry.requestData'
          });
        }

        const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {
          count: 1
        });

        if (firstEntry) {
          // Pick an ID one less than the lowest ID in the object store.
          entry.id = firstEntry.id - 1;
        } else {
          // Otherwise let the auto-incrementor assign the ID.
          delete entry.id;
        }

        entry.queueName = this._queueName;
        await this._db.add(OBJECT_STORE_NAME, entry);
      }
      /**
       * Removes and returns the last entry in the queue matching the `queueName`.
       *
       * @return {Promise<Object>}
       * @private
       */


      async popEntry() {
        return this._removeEntry({
          direction: 'prev'
        });
      }
      /**
       * Removes and returns the first entry in the queue matching the `queueName`.
       *
       * @return {Promise<Object>}
       * @private
       */


      async shiftEntry() {
        return this._removeEntry({
          direction: 'next'
        });
      }
      /**
       * Returns all entries in the store matching the `queueName`.
       *
       * @param {Object} options See {@link module:workbox-background-sync.Queue~getAll}
       * @return {Promise<Array<Object>>}
       * @private
       */


      async getAll() {
        return await this._db.getAllMatching(OBJECT_STORE_NAME, {
          index: INDEXED_PROP,
          query: IDBKeyRange.only(this._queueName)
        });
      }
      /**
       * Deletes the entry for the given ID.
       *
       * WARNING: this method does not ensure the deleted enry belongs to this
       * queue (i.e. matches the `queueName`). But this limitation is acceptable
       * as this class is not publicly exposed. An additional check would make
       * this method slower than it needs to be.
       *
       * @private
       * @param {number} id
       */


      async deleteEntry(id) {
        await this._db.delete(OBJECT_STORE_NAME, id);
      }
      /**
       * Removes and returns the first or last entry in the queue (based on the
       * `direction` argument) matching the `queueName`.
       *
       * @return {Promise<Object>}
       * @private
       */


      async _removeEntry({
        direction
      }) {
        const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {
          direction,
          index: INDEXED_PROP,
          query: IDBKeyRange.only(this._queueName),
          count: 1
        });

        if (entry) {
          await this.deleteEntry(entry.id);
          return entry;
        }
      }
      /**
       * Upgrades the database given an `upgradeneeded` event.
       *
       * @param {Event} event
       * @private
       */


      _upgradeDb(event) {
        const db = event.target.result;

        if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {
          if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {
            db.deleteObjectStore(OBJECT_STORE_NAME);
          }
        }

        const objStore = db.createObjectStore(OBJECT_STORE_NAME, {
          autoIncrement: true,
          keyPath: 'id'
        });
        objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {
          unique: false
        });
      }

    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const serializableProperties = ['method', 'referrer', 'referrerPolicy', 'mode', 'credentials', 'cache', 'redirect', 'integrity', 'keepalive'];
    /**
     * A class to make it easier to serialize and de-serialize requests so they
     * can be stored in IndexedDB.
     *
     * @private
     */

    class StorableRequest {
      /**
       * Accepts an object of request data that can be used to construct a
       * `Request` but can also be stored in IndexedDB.
       *
       * @param {Object} requestData An object of request data that includes the
       *     `url` plus any relevant properties of
       *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.
       * @private
       */
      constructor(requestData) {
        {
          assert_js.assert.isType(requestData, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'StorableRequest',
            funcName: 'constructor',
            paramName: 'requestData'
          });
          assert_js.assert.isType(requestData.url, 'string', {
            moduleName: 'workbox-background-sync',
            className: 'StorableRequest',
            funcName: 'constructor',
            paramName: 'requestData.url'
          });
        } // If the request's mode is `navigate`, convert it to `same-origin` since
        // navigation requests can't be constructed via script.


        if (requestData['mode'] === 'navigate') {
          requestData['mode'] = 'same-origin';
        }

        this._requestData = requestData;
      }
      /**
       * Converts a Request object to a plain object that can be structured
       * cloned or JSON-stringified.
       *
       * @param {Request} request
       * @return {Promise<StorableRequest>}
       *
       * @private
       */


      static async fromRequest(request) {
        const requestData = {
          url: request.url,
          headers: {}
        }; // Set the body if present.

        if (request.method !== 'GET') {
          // Use ArrayBuffer to support non-text request bodies.
          // NOTE: we can't use Blobs becuse Safari doesn't support storing
          // Blobs in IndexedDB in some cases:
          // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457
          requestData.body = await request.clone().arrayBuffer();
        } // Convert the headers from an iterable to an object.


        for (const [key, value] of request.headers.entries()) {
          requestData.headers[key] = value;
        } // Add all other serializable request properties


        for (const prop of serializableProperties) {
          if (request[prop] !== undefined) {
            requestData[prop] = request[prop];
          }
        }

        return new StorableRequest(requestData);
      }
      /**
       * Returns a deep clone of the instances `_requestData` object.
       *
       * @return {Object}
       *
       * @private
       */


      toObject() {
        const requestData = Object.assign({}, this._requestData);
        requestData.headers = Object.assign({}, this._requestData.headers);

        if (requestData.body) {
          requestData.body = requestData.body.slice(0);
        }

        return requestData;
      }
      /**
       * Converts this instance to a Request.
       *
       * @return {Request}
       *
       * @private
       */


      toRequest() {
        return new Request(this._requestData.url, this._requestData);
      }
      /**
       * Creates and returns a deep clone of the instance.
       *
       * @return {StorableRequest}
       *
       * @private
       */


      clone() {
        return new StorableRequest(this.toObject());
      }

    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const TAG_PREFIX = 'workbox-background-sync';
    const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes

    const queueNames = new Set();
    /**
     * Converts a QueueStore entry into the format exposed by Queue. This entails
     * converting the request data into a real request and omitting the `id` and
     * `queueName` properties.
     *
     * @param {Object} queueStoreEntry
     * @return {Object}
     * @private
     */

    const convertEntry = queueStoreEntry => {
      const queueEntry = {
        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),
        timestamp: queueStoreEntry.timestamp
      };

      if (queueStoreEntry.metadata) {
        queueEntry.metadata = queueStoreEntry.metadata;
      }

      return queueEntry;
    };
    /**
     * A class to manage storing failed requests in IndexedDB and retrying them
     * later. All parts of the storing and replaying process are observable via
     * callbacks.
     *
     * @memberof module:workbox-background-sync
     */


    class Queue {
      /**
       * Creates an instance of Queue with the given options
       *
       * @param {string} name The unique name for this queue. This name must be
       *     unique as it's used to register sync events and store requests
       *     in IndexedDB specific to this instance. An error will be thrown if
       *     a duplicate name is detected.
       * @param {Object} [options]
       * @param {Function} [options.onSync] A function that gets invoked whenever
       *     the 'sync' event fires. The function is invoked with an object
       *     containing the `queue` property (referencing this instance), and you
       *     can use the callback to customize the replay behavior of the queue.
       *     When not set the `replayRequests()` method is called.
       *     Note: if the replay fails after a sync event, make sure you throw an
       *     error, so the browser knows to retry the sync event later.
       * @param {number} [options.maxRetentionTime=7 days] The amount of time (in
       *     minutes) a request may be retried. After this amount of time has
       *     passed, the request will be deleted from the queue.
       */
      constructor(name, {
        onSync,
        maxRetentionTime
      } = {}) {
        this._syncInProgress = false;
        this._requestsAddedDuringSync = false; // Ensure the store name is not already being used

        if (queueNames.has(name)) {
          throw new WorkboxError_js.WorkboxError('duplicate-queue-name', {
            name
          });
        } else {
          queueNames.add(name);
        }

        this._name = name;
        this._onSync = onSync || this.replayRequests;
        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;
        this._queueStore = new QueueStore(this._name);

        this._addSyncListener();
      }
      /**
       * @return {string}
       */


      get name() {
        return this._name;
      }
      /**
       * Stores the passed request in IndexedDB (with its timestamp and any
       * metadata) at the end of the queue.
       *
       * @param {Object} entry
       * @param {Request} entry.request The request to store in the queue.
       * @param {Object} [entry.metadata] Any metadata you want associated with the
       *     stored request. When requests are replayed you'll have access to this
       *     metadata object in case you need to modify the request beforehand.
       * @param {number} [entry.timestamp] The timestamp (Epoch time in
       *     milliseconds) when the request was first added to the queue. This is
       *     used along with `maxRetentionTime` to remove outdated requests. In
       *     general you don't need to set this value, as it's automatically set
       *     for you (defaulting to `Date.now()`), but you can update it if you
       *     don't want particular requests to expire.
       */


      async pushRequest(entry) {
        {
          assert_js.assert.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'Queue',
            funcName: 'pushRequest',
            paramName: 'entry'
          });
          assert_js.assert.isInstance(entry.request, Request, {
            moduleName: 'workbox-background-sync',
            className: 'Queue',
            funcName: 'pushRequest',
            paramName: 'entry.request'
          });
        }

        await this._addRequest(entry, 'push');
      }
      /**
       * Stores the passed request in IndexedDB (with its timestamp and any
       * metadata) at the beginning of the queue.
       *
       * @param {Object} entry
       * @param {Request} entry.request The request to store in the queue.
       * @param {Object} [entry.metadata] Any metadata you want associated with the
       *     stored request. When requests are replayed you'll have access to this
       *     metadata object in case you need to modify the request beforehand.
       * @param 